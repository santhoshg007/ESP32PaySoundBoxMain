Preference :
http://arduino.esp8266.com/stable/package_esp8266com_index.json,https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json,https://dl.espressif.com/dl/package_esp32_index.json

Setup Your Development Environment ESP32-S3 EC200U :

	1. Download and Install Arduino IDE
	2. Add ESP32 Boards to Arduino IDE
		Open Arduino IDE and go to File > Preferences.
		In the "Additional Board Manager URLs" field, paste this URL: https://dl.espressif.com/dl/package_esp32_index.json
		Click OK to save
	3. Install the ESP32 Board Package
		Go to Tools > Board > Boards Manager.
		Search for "ESP32" in the Boards Manager.
		Select the "esp32 by Espressif Systems" package and click Install.

	4. Select Your Board
		Go to Tools > Board and select the appropriate board for your device, such as ESP32-S3 Dev Module (or another option that matches your setup).

	5. Choose the Correct Port
		Connect your board to your computer using a USB cable.

		In Arduino IDE, go to Tools > Port and select the port your device is connected to.

	6. Test with a Basic Program
		Open the Blink Example to test your setup:
		Go to File > Examples > 01.Basics > Blink.
		Update the pin number in the code to match the onboard LED pin (e.g., GPIO 2 for most ESP32 boards).
		Upload the code by clicking on the Upload button.
		
Install Library :
-----------------
1. TinyGSM :
	The TinyGSM library for Arduino was authored by Volodymyr Shymanskyy, a software engineer known for developing open-source libraries and tools for IoT applications.

2. Find the Keypad library (author: Mark Stanley, Alexander Brevig).	

3. ArduinoJson library, it's Benoît Blanchon.

4. The TFT_eSPI library is authored and maintained by Bodmer.

5. The author of the PubSubClient library is Nick O'Leary.

6. Search for "Ping" and install the library called Ping by 2banty.

7. Look for a library like "qrcode" (a popular one) or "QRCode" by the "Eliot" library, which is compatible with the Arduino platform.





Install python runnning Sever :
--------------------------------
1. Install python.
2. python -m ensurepip --upgrade
3. pip install pubnub==3.9.0

1. 
2. pip install flask


Install of ngrok :
--------------------

My key : KT2DUWDKBXMKMPEG7XUKGY242QBO5S2Y

Invoke-WebRequest -Uri https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip -OutFile ngrok-v3-stable-windows-amd64.zip
Expand-Archive .\ngrok-v3-stable-windows-amd64.zip -DestinationPath .\

ngrok authtoken KT2DUWDKBXMKMPEG7XUKGY242QBO5S2Y

2uiRysWq7l6t3CrRD56usFLd0jd_6JaNxbAW5hngE9jFHCUSL

or
	1. Run the terminal with adminstrator:
	2. Run the below command:
		Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
	
	3. choco install ngrok
	4. ngrok http 5000

Login the payment gateways webhooks:
-------------------------------------
1. ngrok http 5000
	1. copy n/w forwarding url.
2.  python .\PayPalServerMQTT.py 
1. https://developer.paypal.com/dashboard/webhooksSimulator
		1.1. enter mail and password.
		1.2 Select the testing tool.
		1.3 paste the ngrok forawrding url in webhooks with appending of /webhooks.
			ex. https://d107-2406-7400-9a-6d7d-f1ff-664f-6207-3c33.ngrok-free.app/webhook
		1.4. Now select event and click the send test.
	

CA Certificate :
------------------
	https://www.amazontrust.com/repository/AmazonRootCA1.pem



ESP-IDF Install :
------------------
1. Source code download :
	git clone --recursive https://github.com/espressif/esp-idf.git
2. Set Up ESP-ID :
	cd esp-idf
3. Run the ESP-IDF setup script :
	install.bat
4. python -m pip install pyyaml
	Show : PS D:\Project\IOT\ESP32\SoundBoxPay\esp-idf> python -m pip show pyyaml
4. Set the Environment Variables:
	export IDF_PATH=C:/path/to/esp-idf
5. Install Toolchain: 
	install.bat
6. Check the Installation:
	idf.py --version
	
	
Create and Build Your First Project: 
0. .\export.bat
1. cd examples/get-started/hello_world
2. idf.py set-target esp32s3
3. idf.py fullclean
4. idf.py build
5. idf.py -p COM3 flash
6. idf.py -p COM3 monitor


2. idf.py menuconfig
3. idf.py -p COMx flash
$Env:IDF_PATH = "D:\Project\IOT\ESP32\SoundBoxPay\esp-idf"

 $Env:IDF_PATH="D:\Project\IOT\ESP32\SoundBoxPay\esp-idf"

------------------------------------
TFT Display connectin Procedure :
------------------------------------
ESP32 board

Non-Touch TFT display (e.g., ILI9341, ST7735, etc.)

Jumper wires for wiring the ESP32 and TFT display.

Wiring:
TFT Display Pin	ESP32 Pin
	VCC	3.3V
	GND	GND
	CS	Pin 5
	RESET	Pin 4
	DC (RS)	Pin 2
	SDI(MOSI)	Pin 23
	SCK	Pin 18
	LED	3.3V

Uncomment the configuration line that corresponds to your display. For example, for ILI9341, uncomment the following lines:

cpp
Copy
#define ILI9341_DRIVER
#define TFT_CS     5
#define TFT_RST    4
#define TFT_DC     2
#define TFT_CLK    18
#define TFT_MISO   19
#define TFT_MOSI   23
#define TFT_LED    3.3V

============================
Tft Display configuration :
============================
	Display Color: RGB 65K color
	Screen Size : 3.2(inch)
	Type: TFT
	Driver IC: ILI9341
	Touch: No
	Resolution: 320*240 (Pixel)
	Module Interface: 4-wire SPI interface
	Active Area (AA area): 48.6×64.8(mm)
	Module PCB Size: 55.04×89.3(mm)
	Operating Temperature: -20℃~60℃
	Storage Temperature: -30℃~70℃
	VCC power voltage: 3.3V~5V
	Logic IO port voltage: 3.3V(TTL)
	Weight: 41(g)


LTE Connect :
-------------
Here’s how you should wire the EC200U to the ESP32-S3:


EC200U TX → ESP32 GPIO16 (RX)
EC200U RX → ESP32 GPIO17 (TX)

EC200U GND → ESP32-S3 GND

EC200U VCC → ESP32-S3 5V (Ensure that your EC200U is rated for 5V input, as some modules might require 3.3V)


AT Command Set: The most significant factor is whether the new 4G module uses the same AT command set as the EC200U-CN for core functionalities like:
SIM card status (AT+CPIN?)
Network registration (AT+CEREG?)
Signal quality (AT+CSQ)
PDP context configuration (AT+CGDCONT)
PDP context activation (AT+CGACT)
Pinging (AT+QPING - this is Quectel specific, others might use AT+PING)
SMS sending (AT+CMGF, AT+CMGS)
MQTT commands (if your new module supports them, the commands are likely different).


Use a Suitable Power Supply: Once you know the required voltage, use a separate, regulated power supply that falls within that range. Common options include:
3.7V Li-ion battery: Often a good choice for cellular modules.
5V regulated power supply: Many USB power adapters can work, but ensure they can provide sufficient current (at least 2A is generally recommended).
Adjustable DC-DC buck converter: If you have a higher voltage source, you can use a buck converter to step it down to the required voltage.

Payment method :
----------------
When designing a DIY sound box that incorporates payment methods, you'll need to consider a few factors: the user experience, security, and the practicality of integration. Here's a breakdown of different payment methods and how you might implement them:

1. QR Code Payments (Most Practical for DIY):

	How it works:
		Your sound box displays a QR code.
		The user scans the QR code with their smartphone.
		The QR code directs them to a payment page (e.g., PayPal, Stripe, or a cryptocurrency wallet).
		Once the payment is confirmed, your sound box receives a notification.
	Implementation:
		Server-side: You'll need a server (e.g., a Raspberry Pi or a cloud server) to generate the payment link or QR code. This server handles the communication with the payment gateway.
		ESP32/Microcontroller: Your sound box's microcontroller (e.g., ESP32) displays the QR code on a small screen or OLED display.
	Communication:
		The ESP32 communicates with the server via Wi-Fi or Bluetooth.
	Libraries: 
		Use libraries for QR code generation and communicating with the payment gateway's API.
	Webhooks:
		Use webhooks to receive real-time payment confirmations.
	Pros:
		Contactless and convenient.
		Relatively easy to integrate.
		Supports various payment platforms.
	Cons:
		Requires a smartphone.
		Relies on internet connectivity.
	
2. NFC (Near Field Communication):

How it works:
	The user taps their NFC-enabled smartphone or card on an NFC reader attached to your sound box.
	The payment is processed through a payment gateway.
Implementation:
	NFC Reader: You'll need an NFC reader module.
	Microcontroller: Your microcontroller communicates with the NFC reader.
	Server-side (Optional): You might need a server to handle payment processing and communication with the payment gateway.
Pros:
	Fast and convenient.
	Contactless.
	Cons:
	Requires NFC-enabled devices.
	NFC reader modules can be more complex to integrate.
	Security concerns if not implemented correctly.


3. Cryptocurrency Payments:

	How it works:
		Your sound box displays a cryptocurrency wallet address or a QR code for payment.
		The user sends the cryptocurrency to the address.
		Your sound box monitors the blockchain for payment confirmation.
	Implementation:
		Microcontroller: Your microcontroller displays the wallet address or QR code.
		Internet Connectivity: You'll need internet connectivity to monitor the blockchain.
		Libraries: Use libraries for interacting with the cryptocurrency's API.
	Pros:
		Decentralized and secure.
		Low transaction fees (in some cases).
	Cons:
		Cryptocurrency volatility.
		Requires user familiarity with cryptocurrency.
		Blockchain monitoring adds complexity.


4. Credit/Debit Card Readers (More Complex):

	How it works:
		The user inserts or swipes their credit/debit card in a card reader attached to your sound box.
		The payment is processed through a payment gateway.
	Implementation:
	Card Reader:
		You'll need a certified card reader module.
	Microcontroller: Your microcontroller communicates with the card reader.
	Server-side: You'll need a server to handle payment processing and communication with the payment gateway.
	
	Pros:
		Widely accepted.
	Cons:
		Card reader modules can be expensive.
		Requires PCI DSS compliance (for handling sensitive card data).
		Significantly more complex to implement.
		Security risks are high if not implemented correctly.
		
		
	DIY Considerations:
	Security: 
		Prioritize security in your design. Never store sensitive payment data directly on the microcontroller.
	User Experience: 
		Make the payment process as simple and intuitive as possible.
	Internet Connectivity: 
		If your payment method relies on the internet, ensure a reliable connection.
	Power Consumption: 
		Consider the power consumption of your payment modules.
	Cost: 
		Balance the cost of the payment modules with your budget.
	Software Libraries: 
		utilize available software libraries to make the project easier.
	For most DIY sound box projects, QR code payments offer the best balance of convenience, security, and ease of implementation.	
	

Explanation of Key Components:
Message Queue:

We use a message queue (msgQueue) to pass data between the keyboard task and the main task. The keyboardMonitorTask sends key presses to the main thread, where logic is handled.

Main Task:

	The mainTask is the central control thread. It listens to messages from the keyboardMonitorTask, updates the payment method, and handles the flow of the application. For example, when the user presses '1' for the QR method, it sets the paymentMethod to "QR". When the user presses '#', it processes the payment method and updates the history.

Keyboard Monitor Task:

	The keyboardMonitorTask checks the keypad for user input. Whenever a key is pressed, it sends the key to the main thread via the message queue.

Display Task:

	The displayTask is responsible for updating the screen based on the current application state (home screen, QR code entry, NFC card detection, or payment history).

	Synchronous drawing is used when we need to immediately update the display (e.g., showing the home screen), while asynchronous drawing adds a delay before updating the display (e.g., showing a QR code generation screen).

WiFi Task:

	The wifiTask is running in the background to ensure the device remains connected to WiFi. It attempts to reconnect if the WiFi is disconnected.	
-------------
Sample Code :
-------------------
#include <Arduino.h>
#include <TFT_eSPI.h>
#include <Keypad.h>
#include <WiFi.h>
#include <Wire.h>
#include <PN532_I2C.h>
#include <PN532.h>

// Define TFT display
TFT_eSPI tft = TFT_eSPI(); // TFT display object
#define TFT_CS     5
#define TFT_RST    17
#define TFT_DC     16

// Keypad setup (4x4 matrix)
const byte ROW_NUM = 4;
const byte COLUMN_NUM = 4;
char keys[ROW_NUM][COLUMN_NUM] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}
};
byte pin_rows[ROW_NUM] = {23, 22, 21, 19}; // Adjust to your wiring
byte pin_column[COLUMN_NUM] = {18, 5, 4, 0}; // Adjust to your wiring
Keypad keypad = Keypad(makeKeymap(keys), pin_rows, pin_column, ROW_NUM, COLUMN_NUM);

// NFC Setup
PN532_I2C pn532(Wire);
PN532 nfc(pn532);

// WiFi credentials
const char *ssid = "YourSSID";
const char *password = "YourPassword";

// Message Queue Setup for communication between threads
QueueHandle_t msgQueue;
#define QUEUE_SIZE 10

// Global Variables
String paymentMethod = "";
String enteredAmount = "";
String paymentHistory = "";

// Define Task Handles
TaskHandle_t mainTaskHandle;
TaskHandle_t keyboardTaskHandle;
TaskHandle_t displayTaskHandle;
TaskHandle_t wifiTaskHandle;

// Struct to send data through the message queue
struct Message {
    char key;
};

// Function to initialize the display
void initDisplay() {
    tft.begin();
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE);
}

// Display Thread: Synchronous and Asynchronous Draw
void drawTextSync(const String &text) {
    tft.fillScreen(TFT_BLACK);
    tft.drawString(text, 10, 10);
}

void drawTextAsync(const String &text) {
    // This function simulates async behavior by adding a delay before updating the display.
    delay(2000);
    drawTextSync(text);
}

// Keyboard Monitor Thread: Wait for input and send messages to main thread
void keyboardMonitorTask(void *pvParameters) {
    while (true) {
        char key = keypad.getKey();
        if (key) {
            Message msg;
            msg.key = key;
            // Send the key to the main thread via the message queue
            xQueueSend(msgQueue, &msg, portMAX_DELAY);
        }
        delay(100);
    }
}

// Display Task: Handle display updates
void displayTask(void *pvParameters) {
    while (true) {
        String message;
        // Check message from main task
        if (paymentMethod == "") {
            message = "Home Screen\n1. QR Code\n2. NFC\n3. Payment History";
            drawTextSync(message);
        } else if (paymentMethod == "QR") {
            message = "Enter Amount for QR: " + enteredAmount;
            drawTextAsync(message); // Asynchronous drawing
        } else if (paymentMethod == "NFC") {
            message = "Place NFC Card";
            drawTextAsync(message);
        } else if (paymentMethod == "History") {
            message = "Payment History: " + paymentHistory;
            drawTextSync(message);
        }
        delay(1000);
    }
}

// WiFi Task: Monitor WiFi connection (for status updates, if necessary)
void wifiTask(void *pvParameters) {
    while (true) {
        if (WiFi.status() != WL_CONNECTED) {
            WiFi.begin(ssid, password);
            while (WiFi.status() != WL_CONNECTED) {
                delay(1000);
            }
        }
        delay(5000);
    }
}

// Main Task: Handle logic and flow of the system
void mainTask(void *pvParameters) {
    // Initialize WiFi and display
    WiFi.begin(ssid, password);
    initDisplay();
    
    while (true) {
        Message msg;
        if (xQueueReceive(msgQueue, &msg, portMAX_DELAY)) {
            // Handle the key press from the queue
            if (msg.key == '1') {
                paymentMethod = "QR";
            } else if (msg.key == '2') {
                paymentMethod = "NFC";
            } else if (msg.key == '3') {
                paymentMethod = "History";
            } else if (msg.key == '#') {
                if (paymentMethod == "QR") {
                    paymentHistory += "QR Payment: " + enteredAmount + "\n";
                    enteredAmount = ""; // Reset amount after successful entry
                    paymentMethod = "";
                } else if (paymentMethod == "NFC") {
                    paymentHistory += "NFC Payment: Successful\n";
                    paymentMethod = "";
                }
            } else if (msg.key >= '0' && msg.key <= '9') {
                enteredAmount += msg.key;
            }
        }
    }
}

void setup() {
    Serial.begin(115200);

    // Create message queue
    msgQueue = xQueueCreate(QUEUE_SIZE, sizeof(Message));

    // Create tasks
    xTaskCreate(mainTask, "Main Task", 2048, NULL, 1, &mainTaskHandle);
    xTaskCreate(keyboardMonitorTask, "Keyboard Monitor Task", 2048, NULL, 1, &keyboardTaskHandle);
    xTaskCreate(displayTask, "Display Task", 2048, NULL, 1, &displayTaskHandle);
    xTaskCreate(wifiTask, "WiFi Task", 2048, NULL, 1, &wifiTaskHandle);
}

void loop() {
    // The main loop is empty because the logic is handled by FreeRTOS tasks
}
	
================================
#include <WiFi.h>
#include <TFT_eSPI.h>  // TFT library for ESP32
#include <QRCode.h>     // QRCode library for generating QR codes

// WiFi credentials (for internet connection, if needed)
const char* ssid = "your_wifi_ssid";
const char* password = "your_wifi_password";

// Initialize TFT display
TFT_eSPI tft = TFT_eSPI();  // Use default TFT settings

// Static UPI ID (Replace with your UPI ID)
String upiID = "your_upi@upi";

// Variables for dynamic amount
float amount = 0.0;  // Amount entered by the user

// QR Code size settings
#define QR_SIZE 200

void setup() {
  Serial.begin(115200);
  Serial.println("Starting UPI QR Code Generator");

  // Connect to Wi-Fi (optional if internet access is required)
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");

  // Initialize TFT display
  tft.init();
  tft.setRotation(1);  // Adjust screen orientation
  tft.fillScreen(TFT_WHITE);  // Clear the screen

  // Ask user for the amount to generate UPI QR code
  Serial.print("Enter the amount: ");
  while (Serial.available() == 0) {  // Wait for user input
    delay(100);
  }
  amount = Serial.parseFloat();
  Serial.println(amount);

  // Generate UPI QR Code
  String upiQRData = createUPIString(amount);
  generateAndDisplayQR(upiQRData);
}

void loop() {
  // Main loop, you can implement functionality for continuous updates or handling events
}

String createUPIString(float amount) {
  // Format the UPI string
  String upiString = "upi://pay?pa=" + upiID + "&pn=Merchant&mc=123456&tid=1234567890&tr=1234567890&tn=Payment%20for%20goods&am=";
  upiString += String(amount, 2);  // Append the amount to the UPI string
  upiString += "&cu=INR&url=https://www.merchantwebsite.com";  // Add currency and URL
  return upiString;
}

void generateAndDisplayQR(String upiData) {
  int size = QR_SIZE;
  QRCode qrcode;
  
  // Create QR code from the UPI string
  qrcode.init();
  qrcode.setData(upiData.c_str());
  qrcode.generate();

  // Display the QR code on the TFT screen
  int offsetX = (tft.width() - size) / 2;  // Center the QR code
  int offsetY = (tft.height() - size) / 2;

  tft.fillRect(0, 0, tft.width(), tft.height(), TFT_WHITE);  // Clear the screen
  for (int y = 0; y < size; y++) {
    for (int x = 0; x < size; x++) {
      if (qrcode.getModule(x, y)) {
        tft.fillRect(offsetX + x * 2, offsetY + y * 2, 2, 2, TFT_BLACK);  // Draw QR code module
      }
    }
  }

  Serial.println("UPI QR Code generated and displayed.");
}

	
=================
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>

// Your Wi-Fi credentials
const char *ssid = "your_SSID";
const char *password = "your_PASSWORD";

// Adafruit IO MQTT Broker details
const char *mqtt_server = "io.adafruit.com";
const int mqtt_port = 8883;  // Use 8883 for SSL/TLS encrypted connection (secure)

const char *mqtt_user = "your_adafruit_username";  // Your Adafruit IO username
const char *mqtt_password = "your_adafruit_IO_key";  // Your Adafruit IO key

WiFiClientSecure espClient;  // Secure Wi-Fi client (for SSL/TLS)
PubSubClient client(espClient);  // MQTT client using secure Wi-Fi client

// Amazon's Root CA Certificate (used by Adafruit IO)
const char* ca_cert = \
"-----BEGIN CERTIFICATE-----\n" \
"MIIDdzCCAl+gAwIBAgIJAKz3+/T2bbSaMA0GCSqGSIb3DQEBBQUAMF0xCzAJBgNV\n" \
"BAYTAklOMQswCQYDVQQIDAJFSjELMAkGA1UEBwwCSVYxFDASBgNVBAoMC0FtYXpv\n" \
"biBDb3Jwb3JhdGlvbnMxITAfBgNVBAMMGGd1c3RyYXdpeC1jYS5hd2Ntcy5jb20w\n" \
"HhcNMjMwNjAyMTE0NzMyWhcNMjQwNjAyMTE0NzMyWjBdMQswCQYDVQQGEwJJTjEL\n" \
"MAkGA1UECAwCRUoxCzAJBgNVBAcMAlJZMRQwEgYDVQQKDAtBbWF6b24gQ29ycG9y\n" \
"YXRpb25zMR0wGwYDVQQLDBRDb3Jwb3JhdGUgU2VjdXJpdHkxHDAaBgNVBAMME2d1\n" \
"c3RyYXdpeC1jYS5hd2Ntcy5jb20wggEwDQYJKoZIhvcNAQEBBQADggEBAD5QpkFz\n" \
"DAp6k7TyaHZmckqOa7s/XuGB5rHfpAfqdkZt+nbvVtd1gbh8gfBcnqkk2gtZ6vHq\n" \
"nBz1DaXFcCuKtrckFXHqgHfJMyf3HZF8szCcnRDoToExs0eR8Biy9z/Fth04/kfC\n" \
"QyCkExOJl3uYtATqlkbk49OmyKnI5vUK6GLyY1X1Ay1tqxtmqlE6zwg64zYY2Hb0\n" \
"t4QwHz7lZ7wF5gqOo0tse7cxUSbmjzgZf3Yg3n4uD2by9UsvGnKNN0G0iADewhZG\n" \
"fvCjzF5HKhjAwTLaf7pPCE33bp3diHB4zSv7tL0i/taSdz+9N6A3PTQ0WFMpNJfM\n" \
"2lLOFjmFRw0Pj8WwgyN6gl0jbjsw1Te9HtXKnTnTmOx7zy7YGOaRA9gD0lYdso=\n" \
"-----END CERTIFICATE-----\n";

// Callback function when a message is received
void callback(char *topic, byte *message, unsigned int length) {
  Serial.print("Message arrived on topic: ");
  Serial.print(topic);
  Serial.print(". Message: ");
  for (int i = 0; i < length; i++) {
    Serial.print((char)message[i]);
  }
  Serial.println();
}

// Connect to Wi-Fi
void setup_wifi() {
  Serial.print("Connecting to WiFi...");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }
  Serial.println("Connected to WiFi");
}

// Reconnect to MQTT server if the connection is lost
void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    if (client.connect("ESP32Client", mqtt_user, mqtt_password)) {
      Serial.println("Connected to MQTT (Secure)");
      client.subscribe("your_username/feeds/led");  // Example feed name
    } else {
      Serial.print("Failed to connect to MQTT, rc=");
      Serial.print(client.state());
      Serial.println(" trying again in 5 seconds");
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  setup_wifi();  // Connect to Wi-Fi

  // Set the CA certificate for SSL/TLS verification
  espClient.setTrustAnchors(ca_cert);

  client.setServer(mqtt_server, mqtt_port);  // Set server with secure port
  client.setCallback(callback);  // Set callback function for message handling
}

void loop() {
  if (!client.connected()) {
    reconnect();  // Ensure we're connected to the MQTT server
  }
  client.loop();  // Handle MQTT communication

  // Publish a message to the "led" feed (example)
  client.publish("your_username/feeds/led", "Hello from ESP32!");

  delay(2000);  // Publish a message every 2 seconds
}
==================
Creating a FreeRTOS task for MQTT communication is a good approach, especially if you want to handle MQTT communication in the background without blocking other tasks. Below is an example of how you can create a FreeRTOS task to handle MQTT operations.

In this example, we'll create a FreeRTOS task that connects to an MQTT broker (like Adafruit IO or any other broker) and listens for messages on a topic.

### MQTT Task Setup Using FreeRTOS

1. **Install the PubSubClient Library**: You need to install the PubSubClient library for MQTT. If you're using the ESP32 with the Arduino IDE, this library will work for connecting to the MQTT broker.

2. **Create the MQTT Task**: We'll create an MQTT task that will run the `loop()` function of the MQTT client, keeping the connection alive, and also handle subscribing and publishing messages.

### Example Code

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

// Wi-Fi and MQTT configuration
const char* ssid = "yourSSID";
const char* password = "yourPassword";
const char* mqttServer = "io.adafruit.com";  // Adafruit IO broker or your MQTT server
const int mqttPort = 1883;  // Default MQTT port (use 8883 for SSL)
const char* mqttUser = "yourUsername";  // Adafruit IO Username
const char* mqttPassword = "yourAIOKey"; // Adafruit IO Key
const char* mqttTopic = "SanthoshG/feeds/paymenttrigger"; // Topic to subscribe to

WiFiClient espClient;
PubSubClient mqttClient(espClient);

// Task handle
TaskHandle_t MQTT_TaskHandle = NULL;

// MQTT callback function
void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Message received on topic: ");
  Serial.print(topic);
  Serial.print(" with payload: ");
  for (unsigned int i = 0; i < length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();
}

// Connect to MQTT broker
void connectMQTT() {
  while (!mqttClient.connected()) {
    Serial.print("Attempting MQTT connection...");

    // Attempt to connect
    if (mqttClient.connect("ESP32_Client", mqttUser, mqttPassword)) {
      Serial.println("connected");
      mqttClient.subscribe(mqttTopic);  // Subscribe to the topic
    } else {
      Serial.print("failed, rc=");
      Serial.print(mqttClient.state());
      Serial.println(" try again in 5 seconds");
      delay(5000);
    }
  }
}

// The MQTT task function
void MQTT_Task(void* parameter) {
  while (true) {
    if (!mqttClient.connected()) {
      connectMQTT();  // Reconnect if the connection is lost
    }
    mqttClient.loop();  // Keep the MQTT connection alive
    delay(10); // Small delay to prevent watchdog timeout
  }
}

// Wi-Fi connection task
void connectWiFi() {
  Serial.print("Connecting to WiFi...");
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }

  Serial.println("WiFi connected");
  Serial.println("IP address: " + WiFi.localIP().toString());
}

void setup() {
  Serial.begin(115200);

  // Connect to Wi-Fi
  connectWiFi();

  // Set the MQTT callback function
  mqttClient.setServer(mqttServer, mqttPort);
  mqttClient.setCallback(callback);

  // Create the MQTT task
  xTaskCreatePinnedToCore(
    MQTT_Task,               // Function to run
    "MQTT Task",             // Name of the task
    2048,                    // Stack size (bytes)
    NULL,                    // Parameters to pass to the task
    1,                       // Task priority (1 is low priority)
    &MQTT_TaskHandle,        // Task handle (optional)
    0                        // Core where the task runs (0 or 1)
  );
}

void loop() {
  // Nothing to do in loop, as MQTT is handled in the FreeRTOS task
  // If you want to publish something, you can do it in the main loop or via other tasks
  // mqttClient.publish("SanthoshG/feeds/paymenttrigger", "Hello, world!");
}
```

### Key Steps in the Code:

1. **Wi-Fi and MQTT Setup**:
   - We define the Wi-Fi credentials and the MQTT server details.
   - The `PubSubClient` is used to handle the MQTT protocol.

2. **Callback Function**:
   - The `callback` function is called when a message is received on the subscribed MQTT topic. Here, it simply prints the message payload to the Serial Monitor.

3. **`connectMQTT` Function**:
   - This function tries to connect to the MQTT broker. If the connection fails, it keeps retrying every 5 seconds.

4. **FreeRTOS MQTT Task (`MQTT_Task`)**:
   - This task continuously checks if the MQTT client is connected, and if not, it tries to reconnect.
   - The `mqttClient.loop()` function is called to maintain the connection and handle incoming messages.
   - We add a small delay to prevent a watchdog timeout.

5. **Wi-Fi Connection (`connectWiFi`)**:
   - The `connectWiFi` function connects to the Wi-Fi network.
   - It waits until the ESP32 is connected to the network.

6. **Creating the Task**:
   - `xTaskCreatePinnedToCore()` is used to create the MQTT task. It pins the task to a specific core if necessary (you can pin it to core 0 or core 1). It runs with a low priority in this example.

7. **Main `loop()`**:
   - In the `loop()` function, no code is required for MQTT handling since it's handled in the FreeRTOS task.

### How it Works:
- **Wi-Fi Connection**: First, the device connects to the Wi-Fi network in the `setup()` function.
- **MQTT Task**: The MQTT task (`MQTT_Task`) is created in the `setup()` function and starts running in the background. This task maintains the MQTT connection and handles receiving messages via `mqttClient.loop()`.
- **FreeRTOS**: The MQTT communication runs in the background on a separate FreeRTOS task, allowing your main program (in `loop()`) to perform other operations concurrently without blocking the MQTT communication.

### Notes:
- **Handling MQTT Connection Loss**: If the MQTT connection is lost, the task will attempt to reconnect continuously.
- **Publishing Data**: You can publish data to your MQTT topic anytime using `mqttClient.publish()`. You can call this function in the `loop()` or any other task.
- **FreeRTOS Task Priority**: You can change the priority of the MQTT task based on your needs. The task with higher priority will get more CPU time.

### Conclusion:
This approach of creating an MQTT task using FreeRTOS allows you to run MQTT communication asynchronously and keep the main program free for other operations. By using FreeRTOS tasks, you can efficiently handle multiple concurrent tasks on your ESP32.


The core difference between `xTaskCreate()` and `xTaskCreatePinnedToCore()` lies in how they handle task placement on multi-core systems like the ESP32.

Here's a clear breakdown:

**`xTaskCreate()`:**

* **Core Assignment:**
    * This function does *not* explicitly specify which CPU core the task will run on.
    * The FreeRTOS scheduler will decide which core to run the task on, based on its internal scheduling algorithms.
    * The task might migrate between cores during its execution.
* **Simplicity:**
    * It's simpler to use, as you don't need to worry about core assignments.
    * It's suitable for most general-purpose tasks where core affinity is not critical.
* **Portability:**
    * This function is more portable across different FreeRTOS implementations, even those running on single-core processors.
* **Usage:**
    * Use this when you don't care which core a task runs on, or when you are running on a single core processor.

**`xTaskCreatePinnedToCore()`:**

* **Core Assignment:**
    * This function *explicitly* pins the task to a specific CPU core.
    * The task will run exclusively on the core specified by the `xCoreID` parameter.
    * This prevents task migration between cores.
* **Control:**
    * It provides finer control over task placement, allowing you to optimize performance and meet real-time requirements.
* **ESP32 Specific:**
    * This function is specific to multi-core FreeRTOS implementations, such as the one used on the ESP32.
* **Usage:**
    * Use this when you need to control which core a task runs on, such as for performance optimization, real-time requirements, or peripheral control.

**In essence:**

* `xTaskCreate()`: "Let the scheduler decide where to run the task."
* `xTaskCreatePinnedToCore()`: "Run this task on *this specific* core."

**When to Choose Which:**

* Use `xTaskCreate()` for most general-purpose tasks.
* Use `xTaskCreatePinnedToCore()` when:
    * You have performance-critical tasks that need to run on a specific core.
    * You have real-time tasks that need to avoid interruptions from other cores.
    * You are trying to achieve core affinity, where a specific core is dedicated to a type of task.
* It is generally recommended to use xTaskCreatePinnedToCore on the ESP32, as it allows for better control of the system.

Here are the **APN settings** for mobile carriers in **India** and **Singapore**. These settings are required for your **EC200U LTE module** to establish an internet connection via your mobile network provider.

### APN Configuration for **India**:

1. **Airtel (India)**:
   - **APN**: `airtelgprs.com`
   - **Username**: `not set`
   - **Password**: `not set`
   - **MCC**: `404`
   - **MNC**: `10`

2. **Jio (India)**:
   - **APN**: `jionet`
   - **Username**: `not set`
   - **Password**: `not set`
   - **MCC**: `405`
   - **MNC**: `857`

3. **Vodafone Idea (India)**:
   - **APN**: `www`
   - **Username**: `not set`
   - **Password**: `not set`
   - **MCC**: `404`
   - **MNC**: `20` (or `45` depending on the region)

4. **BSNL (India)**:
   - **APN**: `bsnlnet`
   - **Username**: `not set`
   - **Password**: `not set`
   - **MCC**: `404`
   - **MNC**: `11`

### APN Configuration for **Singapore**:

1. **Singtel (Singapore)**:
   - **APN**: `internet`
   - **Username**: `not set`
   - **Password**: `not set`
   - **MCC**: `525`
   - **MNC**: `01`

2. **StarHub (Singapore)**:
   - **APN**: `shwap`
   - **Username**: `not set`
   - **Password**: `not set`
   - **MCC**: `525`
   - **MNC**: `02`

3. **M1 (Singapore)**:
   - **APN**: `internet`
   - **Username**: `not set`
   - **Password**: `not set`
   - **MCC**: `525`
   - **MNC**: `03`

---

### How to Set the APN:

1. **For India**: Depending on which Indian carrier you're using, replace `"your_apn_here"` in the AT command with the correct APN for that carrier. Here’s an example for **Jio**:

   ```cpp
   const char* AT_CGDCONT = "AT+CGDCONT=1,\"IP\",\"jionet\"\r\n";
   ```

   Similarly, replace it for Airtel, Vodafone, or BSNL by using the respective APN strings.

2. **For Singapore**: If you're using **Singtel**, replace `"your_apn_here"` with `internet`:

   ```cpp
   const char* AT_CGDCONT = "AT+CGDCONT=1,\"IP\",\"internet\"\r\n";
   ```

   For **StarHub**, it would be:

   ```cpp
   const char* AT_CGDCONT = "AT+CGDCONT=1,\"IP\",\"shwap\"\r\n";
   ```

   For **M1**, it would be:

   ```cpp
   const char* AT_CGDCONT = "AT+CGDCONT=1,\"IP\",\"internet\"\r\n";
   ```

### Final Example (for Jio in India):

```cpp
const char* AT_CGDCONT = "AT+CGDCONT=1,\"IP\",\"jionet\"\r\n";
```

### How to Find APN Settings:

1. **Check your Mobile Carrier’s Website**: Most mobile carriers list their APN settings on their official website, or you can contact their customer support for the correct settings.
2. **SIM Card Configuration**: In some cases, the mobile carrier may automatically configure the APN on your device when you insert the SIM card.

Once you configure the correct APN, your EC200U module should be able to connect to the internet using the mobile network in India or Singapore.
=====================================
Pay Pal Response for event :
=====================================
1. Response :
-------------
	{
  "id": "WHPOC2017-9WY437509V4499423",
  "create_time": "2017-02-14T18:28:16Z",
  "resource_type": "order",
  "event_type": "PAYMENT.ORDER.CREATED",
  "summary": "A Payment order is created",
  "resource": {
    "parent_payment": "PAY-8U555528BH195130VLCRUVPA",
    "update_time": "2017-02-14T18:28:37Z",
    "amount": {
      "total": "4.54",
      "currency": "USD"
    },
    "is_final_capture": true,
    "create_time": "2017-02-14T18:28:16Z",
    "transaction_fee": {
      "value": "0.43",
      "currency": "USD"
    },
    "links": [
      {
        "href": "https://www.api.paypal.com/v1/payments/capture/9WY437509V4499423",
        "rel": "self",
        "method": "GET"
      },
      {
        "href": "https://www.api.paypal.com/v1/payments/capture/9WY437509V4499423/refund",
        "rel": "refund",
        "method": "POST"
      },
      {
        "href": "https://www.api.paypal.com/v1/payments/orders/O-7K226695UU6131610",
        "rel": "order",
        "method": "GET"
      },
      {
        "href": "https://www.api.paypal.com/v1/payments/payment/PAY-8U555528BH195130VLCRUVPA",
        "rel": "parent_payment",
        "method": "GET"
      }
    ],
    "id": "O-7K226695UU6131610",
    "state": "completed",
    "reasonCode": "None"
  },
  "links": [
    {
      "href": "https://api.paypal.com/v1/notifications/webhooks-events/WHPOC2017-9WY437509V4499423",
      "rel": "self",
      "method": "GET",
      "encType": "application/json"
    },
    {
      "href": "https://api.paypal.com/v1/notifications/webhooks-events/WHPOC2017-9WY437509V4499423/resend",
      "rel": "resend",
      "method": "POST",
      "encType": "application/json"
    }
  ],
  "event_version": "1.0"
}